#!/bin/bash
# https://github.com/jnvsor/screencap/graphs/contributors

#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

rounding_filter="scale=w=trunc(in_w/2)*2:h=trunc(in_h/2)*2"
# This filter rescales video to multiples of 2 because encoders hate odd numbers

# Defaults
executable="ffmpeg"
threads=2

cap_fps="30"
cap_size="hd1080"
cap_scale="w=-1:h=720"
cap_out=( -c:v:0 "libx264" -pix_fmt yuv444p -preset "ultrafast" -qp 0 )

video_in=( -f video4linux2 -i /dev/video0 )
video_out=( -c:v:1 libx264 -pix_fmt yuv444p -preset "ultrafast" -qp 0 )
video_map=1

audio_in=(
  -f pulse -name "screencap -> system audio" -channel_layout "stereo" -i "alsa_output.pci-0000_00_1b.0.analog-stereo.monitor"
  -f pulse -name "screencap -> headset mic"  -channel_layout "stereo" -i "alsa_input.pci-0000_00_1b.0.analog-stereo"
)
audio_out=( -c:a "libmp3lame" )
audio_map=2


usage(){
cat << EOF
usage: $(basename $0) [options] filename

OPTIONS:

  -h, --help
    Show this message

  -r, --fps
    Framerate in FPS

  -i, --input
    Input size in WxH or "window" to pick one with xwininfo

  -o, --output
    Output size.-1 is wildcard to maintain aspect ratio eg: \`w=-1:h=720\`
    or \`default\` for no scaling

  --blind
    Disable video recording

  --mute
    Disable audio recording

  -t, --threads
    Number of threads to use

  --
    Stop screencap receiving input and pass all following parameters to command

EOF
}


# Check for user input
while :
do
  case "$1" in
    --help|-h)
      usage
      exit 0
      ;;

    --fps|-r)
      cap_fps="$2"
      shift 2
      ;;

    --input|-i)
      if [ "$2" == "window" ]; then
        wininfo="$(xwininfo)"
        u_cap_size="$(echo "$wininfo" |
            awk '/Width:/{w=$2} /Height:/{h=$2} END{printf("%dx%d", w, h)}')"
        cap_offset="$(echo "$wininfo" | awk '
            /Absolute upper-left X:/{x=$4}
            /Absolute upper-left Y:/{y=$4}
            END{printf("+%d,%d", x, y)}')"
      else
        u_cap_size="$2"
      fi
      shift 2
      ;;

    --output|-o)
      case "$2" in
        default|scale|noscale|in) # any of these keywords will disable scaling
          unset cap_scale
          ;;

        *)
          u_cap_scale="$2"
          ;;
      esac
      shift 2
      ;;

    --blind)
      blind=true
      shift
      ;;

    --mute)
      mute=true
      shift
      ;;

    --threads|-t)
      threads="$2"
      shift 2
      ;;

    --)
      shift
      break
      ;;

    *)
      break
      ;;
  esac
done


# Input post-processing
if [ -n "$u_cap_size" ]; then
  unset cap_scale
  cap_size=$u_cap_size
fi

if [ -n "$u_cap_scale" ]; then
  cap_scale=$u_cap_scale
fi

if [ -n "$cap_scale" ]; then
  cap_scale="scale=$cap_scale,"
fi

cap_map=1
cap_in=( -f x11grab -framerate $cap_fps -s $cap_size -i :0.0$cap_offset )
cap_filter=( -filter:v:0 "${cap_scale}${rounding_filter}" )
# Last part rescales video to multiples of 2 because encoders hate odd numbers

if [ -n "$blind" ]; then
  cap_map=0
  unset cap_in
  unset cap_filter
  unset cap_out
  video_map=0
  unset video_in
  unset video_out
fi

if [ -n "$mute" ]; then
  audio_map=0
  unset audio_in
  unset audio_out
fi

maps=()
for((i=0;i< $cap_map + $video_map + $audio_map;i++))
do
  maps+=( -map $i )
done


# Build final command
set -x
$executable \
"${cap_in[@]}" \
"${video_in[@]}" \
"${audio_in[@]}" \
"${maps[@]}" \
"${cap_filter[@]}" \
"${cap_out[@]}" \
"${video_out[@]}" \
"${audio_out[@]}" \
-threads $threads \
-y "$@"